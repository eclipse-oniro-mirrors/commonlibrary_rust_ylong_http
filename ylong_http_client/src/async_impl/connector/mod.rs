// Copyright (c) 2023 Huawei Device Co., Ltd.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Asynchronous `Connector` trait and `HttpConnector` implementation.

mod stream;

use core::future::Future;
use std::error::Error;
use std::io;

/// Information of an IO.
pub use stream::ConnInfo;
use ylong_http::request::uri::Uri;

use crate::runtime::{AsyncRead, AsyncWrite, TcpStream};
use crate::util::config::ConnectorConfig;

/// `Connector` trait used by `async_impl::Client`. `Connector` provides
/// asynchronous connection establishment interfaces.
pub trait Connector {
    /// Streams that this connector produces.
    type Stream: AsyncRead + AsyncWrite + ConnInfo + Unpin + Sync + Send + 'static;
    /// Possible errors that this connector may generate when attempting to
    /// connect.
    type Error: Into<Box<dyn Error + Sync + Send>>;
    /// Futures generated by this connector when attempting to create a stream.
    type Future: Future<Output = Result<Self::Stream, Self::Error>> + Unpin + Sync + Send + 'static;

    /// Attempts to establish a connection.
    fn connect(&self, uri: &Uri) -> Self::Future;
}

/// Connector for creating HTTP or HTTPS connections asynchronously.
///
/// `HttpConnector` implements `async_impl::Connector` trait.
#[derive(Default)]
pub struct HttpConnector {
    config: ConnectorConfig,
}

impl HttpConnector {
    /// Creates a new `HttpConnector` with a `ConnectorConfig`.
    pub(crate) fn new(config: ConnectorConfig) -> HttpConnector {
        HttpConnector { config }
    }
}

async fn tcp_stream(addr: &str) -> io::Result<TcpStream> {
    TcpStream::connect(addr)
        .await
        .and_then(|stream| match stream.set_nodelay(true) {
            Ok(()) => Ok(stream),
            Err(e) => Err(e),
        })
}

#[cfg(not(feature = "__tls"))]
mod no_tls {
    use core::future::Future;
    use core::pin::Pin;
    use std::io::Error;

    use ylong_http::request::uri::Uri;

    use super::{tcp_stream, Connector, HttpConnector};
    use crate::async_impl::connector::stream::HttpStream;
    use crate::async_impl::interceptor::{ConnDetail, ConnProtocol};
    use crate::runtime::TcpStream;

    impl Connector for HttpConnector {
        type Stream = HttpStream<TcpStream>;
        type Error = Error;
        type Future =
            Pin<Box<dyn Future<Output = Result<Self::Stream, Self::Error>> + Sync + Send>>;

        fn connect(&self, uri: &Uri) -> Self::Future {
            // Checks if this uri need be proxied.
            let mut is_proxy = false;
            let mut addr = uri.authority().unwrap().to_string();
            if let Some(proxy) = self.config.proxies.match_proxy(uri) {
                addr = proxy.via_proxy(uri).authority().unwrap().to_string();
                is_proxy = true;
            }
            Box::pin(async move {
                let stream = tcp_stream(&addr).await?;
                let local = stream.local_addr()?;
                let peer = stream.peer_addr()?;
                let detail = ConnDetail {
                    protocol: ConnProtocol::Tcp,
                    alpn: None,
                    local,
                    peer,
                    addr,
                    proxy: is_proxy,
                };
                Ok(HttpStream::new(stream, detail))
            })
        }
    }
}

#[cfg(feature = "__tls")]
mod tls {
    use core::future::Future;
    use core::pin::Pin;
    use std::error;
    use std::fmt::{Debug, Display, Formatter};
    use std::io::{Error, ErrorKind, Write};

    use ylong_http::request::uri::{Scheme, Uri};

    use super::{tcp_stream, Connector, HttpConnector};
    use crate::async_impl::connector::stream::HttpStream;
    use crate::async_impl::interceptor::{ConnDetail, ConnProtocol};
    use crate::async_impl::ssl_stream::{AsyncSslStream, MixStream};
    use crate::runtime::{AsyncReadExt, AsyncWriteExt, TcpStream};

    impl Connector for HttpConnector {
        type Stream = HttpStream<MixStream<TcpStream>>;
        type Error = Error;
        type Future =
            Pin<Box<dyn Future<Output = Result<Self::Stream, Self::Error>> + Sync + Send>>;

        fn connect(&self, uri: &Uri) -> Self::Future {
            // Make sure all parts of uri is accurate.
            let mut addr = uri.authority().unwrap().to_string();
            let host = uri.host().unwrap().as_str().to_string();
            let port = uri.port().unwrap().as_u16().unwrap();
            let mut auth = None;
            let mut is_proxy = false;

            if let Some(proxy) = self.config.proxies.match_proxy(uri) {
                addr = proxy.via_proxy(uri).authority().unwrap().to_string();
                auth = proxy
                    .intercept
                    .proxy_info()
                    .basic_auth
                    .as_ref()
                    .and_then(|v| v.to_string().ok());
                is_proxy = true;
            }

            let host_name = uri
                .host()
                .map(|host| host.to_string())
                .unwrap_or_else(|| "no host in uri".to_string());

            match *uri.scheme().unwrap() {
                Scheme::HTTP => Box::pin(async move {
                    let stream = tcp_stream(&addr).await?;
                    let local = stream.local_addr()?;
                    let peer = stream.peer_addr()?;
                    let detail = ConnDetail {
                        protocol: ConnProtocol::Tcp,
                        alpn: None,
                        local,
                        peer,
                        addr,
                        proxy: is_proxy,
                    };

                    Ok(HttpStream::new(MixStream::Http(stream), detail))
                }),
                Scheme::HTTPS => {
                    let config = self.config.tls.clone();
                    Box::pin(async move {
                        let mut tcp = tcp_stream(&addr).await?;
                        let local = tcp.local_addr()?;
                        let peer = tcp.peer_addr()?;
                        if is_proxy {
                            tcp = tunnel(tcp, host, port, auth).await?;
                        };

                        let pinned_key = config.pinning_host_match(addr.as_str());
                        let mut stream = config
                            .ssl_new(&host_name)
                            .and_then(|ssl| AsyncSslStream::new(ssl.into_inner(), tcp, pinned_key))
                            .map_err(|e| Error::new(ErrorKind::Other, e))?;

                        Pin::new(&mut stream)
                            .connect()
                            .await
                            .map_err(|e| Error::new(ErrorKind::Other, e))?;

                        let alpn = stream.negotiated_alpn_protocol().map(Vec::from);
                        let detail = ConnDetail {
                            protocol: ConnProtocol::Tcp,
                            alpn,
                            local,
                            peer,
                            addr,
                            proxy: is_proxy,
                        };

                        Ok(HttpStream::new(MixStream::Https(stream), detail))
                    })
                }
            }
        }
    }

    async fn tunnel(
        mut conn: TcpStream,
        host: String,
        port: u16,
        auth: Option<String>,
    ) -> Result<TcpStream, Error> {
        let mut req = Vec::new();

        write!(
            &mut req,
            "CONNECT {host}:{port} HTTP/1.1\r\nHost: {host}:{port}\r\n"
        )?;

        if let Some(value) = auth {
            write!(&mut req, "Proxy-Authorization: Basic {value}\r\n")?;
        }

        write!(&mut req, "\r\n")?;

        conn.write_all(&req).await?;

        let mut buf = [0; 8192];
        let mut pos = 0;

        loop {
            let n = conn.read(&mut buf[pos..]).await?;

            if n == 0 {
                return Err(other_io_error(CreateTunnelErr::Unsuccessful));
            }

            pos += n;
            let resp = &buf[..pos];
            if resp.starts_with(b"HTTP/1.1 200") || resp.starts_with(b"HTTP/1.0 200") {
                if resp.ends_with(b"\r\n\r\n") {
                    return Ok(conn);
                }
                if pos == buf.len() {
                    return Err(other_io_error(CreateTunnelErr::ProxyHeadersTooLong));
                }
            } else if resp.starts_with(b"HTTP/1.1 407") {
                return Err(other_io_error(CreateTunnelErr::ProxyAuthenticationRequired));
            } else {
                return Err(other_io_error(CreateTunnelErr::Unsuccessful));
            }
        }
    }

    fn other_io_error(err: CreateTunnelErr) -> Error {
        Error::new(ErrorKind::Other, err)
    }

    enum CreateTunnelErr {
        ProxyHeadersTooLong,
        ProxyAuthenticationRequired,
        Unsuccessful,
    }

    impl Debug for CreateTunnelErr {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::ProxyHeadersTooLong => f.write_str("Proxy headers too long for tunnel"),
                Self::ProxyAuthenticationRequired => f.write_str("Proxy authentication required"),
                Self::Unsuccessful => f.write_str("Unsuccessful tunnel"),
            }
        }
    }

    impl Display for CreateTunnelErr {
        fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
            Debug::fmt(self, f)
        }
    }

    impl error::Error for CreateTunnelErr {}

    #[cfg(all(test, feature = "__tls"))]
    mod ut_create_tunnel_err_debug {
        #[cfg(feature = "ylong_base")]
        use ylong_runtime::io::AsyncWriteExt;

        #[cfg(feature = "ylong_base")]
        use crate::async_impl::connector::tcp_stream;
        use crate::async_impl::connector::tls::CreateTunnelErr;
        #[cfg(feature = "ylong_base")]
        use crate::async_impl::connector::tls::{other_io_error, tunnel};
        #[cfg(feature = "ylong_base")]
        use crate::start_tcp_server;
        #[cfg(feature = "ylong_base")]
        use crate::util::test_utils::{format_header_str, TcpHandle};

        /// UT test cases for debug of`CreateTunnelErr`.
        ///
        /// # Brief
        /// 1. Checks `CreateTunnelErr` debug by calling `CreateTunnelErr::fmt`.
        /// 2. Checks if the result is as expected.
        #[test]
        fn ut_create_tunnel_error_debug() {
            assert_eq!(
                format!("{:?}", CreateTunnelErr::ProxyHeadersTooLong),
                "Proxy headers too long for tunnel"
            );
            assert_eq!(
                format!("{:?}", CreateTunnelErr::ProxyAuthenticationRequired),
                "Proxy authentication required"
            );
            assert_eq!(
                format!("{:?}", CreateTunnelErr::Unsuccessful),
                "Unsuccessful tunnel"
            );
            assert_eq!(
                format!("{}", CreateTunnelErr::ProxyHeadersTooLong),
                "Proxy headers too long for tunnel"
            );
            assert_eq!(
                format!("{}", CreateTunnelErr::ProxyAuthenticationRequired),
                "Proxy authentication required"
            );
            assert_eq!(
                format!("{}", CreateTunnelErr::Unsuccessful),
                "Unsuccessful tunnel"
            );
        }

        /// UT test cases for `tunnel`.
        ///
        /// # Brief
        /// 1. Creates a `tcp stream` by calling `tcp_stream`.
        /// 2. Sends a `Request` by `tunnel`.
        /// 3. Checks if the result is as expected.
        #[cfg(feature = "ylong_base")]
        #[test]
        fn ut_ssl_tunnel_error() {
            let mut handles = vec![];
            start_tcp_server!(
               Handles: handles,
               EndWith: "\r\n\r\n",
               Shutdown: std::net::Shutdown::Both,
            );
            let handle = handles.pop().expect("No more handles !");

            let handle = ylong_runtime::spawn(async move {
                let tcp = tcp_stream(handle.addr.as_str()).await.unwrap();
                let res = tunnel(
                    tcp,
                    String::from("ylong_http.com"),
                    443,
                    Some(String::from("base64 bytes")),
                )
                .await;
                assert_eq!(
                    format!("{:?}", res.err()),
                    format!("{:?}", Some(other_io_error(CreateTunnelErr::Unsuccessful)))
                );
                handle
                    .server_shutdown
                    .recv()
                    .expect("server send order failed !");
            });
            ylong_runtime::block_on(handle).unwrap();

            start_tcp_server!(
               Handles: handles,
               EndWith: "\r\n\r\n",
               Response: {
                   Status: 407,
                   Version: "HTTP/1.1",
                   Header: "Content-Length", "11",
                   Body: "METHOD GET!",
               },
               Shutdown: std::net::Shutdown::Both,
            );
            let handle = handles.pop().expect("No more handles !");

            let handle = ylong_runtime::spawn(async move {
                let tcp = tcp_stream(handle.addr.as_str()).await.unwrap();
                let res = tunnel(
                    tcp,
                    String::from("ylong_http.com"),
                    443,
                    Some(String::from("base64 bytes")),
                )
                .await;
                assert_eq!(
                    format!("{:?}", res.err()),
                    format!(
                        "{:?}",
                        Some(other_io_error(CreateTunnelErr::ProxyAuthenticationRequired))
                    )
                );
                handle
                    .server_shutdown
                    .recv()
                    .expect("server send order failed !");
            });
            ylong_runtime::block_on(handle).unwrap();

            start_tcp_server!(
               Handles: handles,
               EndWith: "\r\n\r\n",
               Response: {
                   Status: 402,
                   Version: "HTTP/1.1",
                   Header: "Content-Length", "11",
                   Body: "METHOD GET!",
               },
               Shutdown: std::net::Shutdown::Both,
            );
            let handle = handles.pop().expect("No more handles !");

            let handle = ylong_runtime::spawn(async move {
                let tcp = tcp_stream(handle.addr.as_str()).await.unwrap();
                let res = tunnel(
                    tcp,
                    String::from("ylong_http.com"),
                    443,
                    Some(String::from("base64 bytes")),
                )
                .await;
                assert_eq!(
                    format!("{:?}", res.err()),
                    format!("{:?}", Some(other_io_error(CreateTunnelErr::Unsuccessful)))
                );
                handle
                    .server_shutdown
                    .recv()
                    .expect("server send order failed !");
            });
            ylong_runtime::block_on(handle).unwrap();
        }

        /// UT test cases for `tunnel`.
        ///
        /// # Brief
        /// 1. Creates a `tcp stream` by calling `tcp_stream`.
        /// 2. Sends a `Request` by `tunnel`.
        /// 3. Checks if the result is as expected.
        #[cfg(feature = "ylong_base")]
        #[test]
        fn ut_ssl_tunnel_connect() {
            let mut handles = vec![];

            start_tcp_server!(
               Handles: handles,
               EndWith: "\r\n\r\n",
                Response: {
                   Status: 200,
                   Version: "HTTP/1.1",
                   Body: "",
               },
               Shutdown: std::net::Shutdown::Both,
            );
            let handle = handles.pop().expect("No more handles !");

            let handle = ylong_runtime::spawn(async move {
                let tcp = tcp_stream(handle.addr.as_str()).await.unwrap();
                let res = tunnel(
                    tcp,
                    String::from("ylong_http.com"),
                    443,
                    Some(String::from("base64 bytes")),
                )
                .await;
                assert!(res.is_ok());
                handle
                    .server_shutdown
                    .recv()
                    .expect("server send order failed !");
            });
            ylong_runtime::block_on(handle).unwrap();
        }

        /// UT test cases for response beyond size of `tunnel`.
        ///
        /// # Brief
        /// 1. Creates a `tcp stream` by calling `tcp_stream`.
        /// 2. Sends a `Request` by `tunnel`.
        /// 3. Checks if the result is as expected.
        #[cfg(feature = "ylong_base")]
        #[test]
        fn ut_ssl_tunnel_resp_beyond_size() {
            let mut handles = vec![];

            let buf = vec![b'b'; 8192];
            let body = String::from_utf8(buf).unwrap();

            start_tcp_server!(
               Handles: handles,
               EndWith: "\r\n\r\n",
                Response: {
                   Status: 200,
                   Version: "HTTP/1.1",
                   Header: "Content-Length", "11",
                   Body: body.as_str(),
               },
               Shutdown: std::net::Shutdown::Both,
            );
            let handle = handles.pop().expect("No more handles !");

            let handle = ylong_runtime::spawn(async move {
                let tcp = tcp_stream(handle.addr.as_str()).await.unwrap();
                let res = tunnel(
                    tcp,
                    String::from("ylong_http.com"),
                    443,
                    Some(String::from("base64 bytes")),
                )
                .await;
                assert_eq!(
                    format!("{:?}", res.err()),
                    format!(
                        "{:?}",
                        Some(other_io_error(CreateTunnelErr::ProxyHeadersTooLong))
                    )
                );
                handle
                    .server_shutdown
                    .recv()
                    .expect("server send order failed !");
            });
            ylong_runtime::block_on(handle).unwrap();
        }
    }
}
